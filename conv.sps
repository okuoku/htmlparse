(import (rnrs)
        (shorten)
        (wak htmlprag)
        (system)
        (yuni util combinators)
        (only (mosh pp) pp))

(define transtbl
  '(("Anything else" . "Anything else")
    ("EOF" . "EOF")
    ("U+0000 NULL" . #\nul)
    ("U+0009 CHARACTER TABULATION (tab)" . #\x9)
    ("U+000A LINE FEED (LF)" . #\xa)
    ("U+000C FORM FEED (FF)" . #\xc)
    ("U+0020 SPACE" . #\space)
    ("U+0021 EXCLAMATION MARK (!)" . #\!)
    ("U+0022 QUOTATION MARK (\")" . #\")
    ("U+0026 AMPERSAND (&)" . #\&)
    ("U+0027 APOSTROPHE (')" . #\')
    ("U+002D HYPHEN-MINUS (-)" . #\-)
    ("U+002F SOLIDUS (/)" . #\/)
    ("U+003C LESS-THAN SIGN (<)" . #\<)
    ("U+003D EQUALS SIGN (=)" . #\=)
    ("U+003E GREATER-THAN SIGN (>)" . #\>)
    ("U+003F QUESTION MARK (?)" . #\?)
    ("U+0041 LATIN CAPITAL LETTER A through to U+005A LATIN CAPITAL LETTER Z" . "A-Z")
    ("U+0060 GRAVE ACCENT (`)" . #\`)
    ("U+0061 LATIN SMALL LETTER A through to U+007A LATIN SMALL LETTER Z" . "a-z")))

(define (trans str)
  (let ((a (assoc str transtbl)))
    (if a
      (cdr a)
      (assertion-violation 'trans "invalid character class" str))))

(define src (file->string "tokenization.html"))

(define (sum-state-h5 x)
  ;(h5 (^ (id "data-state"))
  ;    (span (^ (class "secno")) "8.2.4.1 ")
  ;    (dfn "Data state"))
  ; => ("data-state" "8.2.4.1" "Data State")
  (let ((id (cadr (cadr (cadr x))))
        (secno (caddr (caddr x)))
        (name (cadddr x)))
    (list (string->symbol id) secno (if (pair? name) (find string? name) name))))

(define (phase0 l)
  ;; select (div (^ (class "impl"))
  ;;         ...)
  ;; and filter out strings.
  (define (filt d) (filter (^e (not (string? e))) d))
  (and (pair? l)
       (let ((a (car l))
             (d (cdr l)))
         (or (and (eq? 'div a) ;; check: a:div d:((^ (class "impl")) ... )
                  (pair? d) (pair? (car d)) (eq? '^ (caar d)) 
                  (eq? 'class (caadar d))
                  (string=? "impl" (cadadr (car d)))
                  (filt d))
             (phase0 a)
             (phase0 d)))))

(define (phase1 l)
  ;; join every string line in SHTML
  (define (itr cur acc rest)
    (define (finish)
      (if (string=? acc "")
        cur
        (cons acc cur)))
    (define (flush push next)
        (itr (cons push (finish)) "" next))
    (define (filt x)
      (or (and (not (string=? "" x))
               (char=? #\newline (string-ref x (- (string-length x) 1)))
               (substring x 0 (- (string-length x) 1)))
          x))
    (if (pair? rest)
      (let ((a (car rest))
            (d (cdr rest)))
        (cond
          ((pair? a)
           (flush (phase1 a) d))
          ((string? a)
           (itr cur (string-append acc (filt a)) d))
          (else ;; Huh?
            (flush a d))))
      (reverse (finish))))
  (itr '() "" l))

(define (phase2 l)
  ;; collect h5 part and emit ((H5. P/D) ...)
  (define (itr cur acc rest)
    (if (pair? rest)
      (let ((a (car rest))
            (d (cdr rest)))
        (if (eq? (car a) 'h5)
          (if acc
            (itr (cons (reverse acc) cur) (list (sum-state-h5 a)) d)
            (itr cur (list (sum-state-h5 a)) d))
          (if acc
            (itr cur (cons a acc) d)
            (itr cur #f d))))
      (reverse cur)))
  (itr '() #f l))

(define (phase3 l)
  ;; fold DL tag.
  (define (fld l)
    (define (itr cur acc rest)
      (if (pair? rest)
        (let ((a (car rest))
              (d (cdr rest)))
          (if (pair? a)
            (case (car a)
              ((^) (itr cur acc d))
              ((dt)
               (itr cur (cons (trans (cadr a)) acc) d))
              ((dd)
               (itr (cons (cons (reverse acc) (cdr a)) cur) '() d))
              (else
                (assertion-violation 'phase3 "Invalid datum" l a)))
            (assertion-violation 'phase3 "Invalid datum" l a)))
        (cons 'rule (reverse cur))))
    (itr '() '() l))
  (define (conv e)
    (define (cleanup e)
      (filter (^e (not (string? e))) e))
    (or (and (pair? e) (eq? 'dl (car e))
             (let ((table (cdr (cleanup e))))
               (fld table)))
        e))
  (define (proc e)
    (map conv e))
  (map proc l))

(define (phase4 l)
  ;; fold A tag.
  ;; (a (^ (href "hoge")) "text") => (link "hoge" "text")
  (define (do-conv x)
    (let ((target (cadr (cadr (cadr x))))
          (text (find string? x)))
      (cond
        ((and (not (string=? "" target))
              (char=? #\# (string-ref target 0)))
         (list 'ref (string->symbol (substring target 1 (string-length target))) text))
        ((string=? text "next input character")
         '(next-input-character))
        ((string=? target "parsing.html#current-input-character")
         '(current-input-character))
        ((string=? target "parsing.html#parse-error")
         '(parse-error))
        (else
         (list 'link target text)))))
  (if (pair? l)
    (let ((a (car l))
          (d (cdr l)))
      (if (and (pair? a) (eq? (car a) 'a))
        (cons (do-conv a) (phase4 d))
        (cons (phase4 a) (phase4 d))))
    l))

#|
(define (emit-inputdef)
  (when (file-exists? "inputdef.txt")
    (delete-file "inputdef.txt"))
  (call-with-output-file 
    "inputdef.txt"
    (^p
      (define (proc e)
        (if (and (pair? e) (eq? 'rule (car e)))
          (for-each (^x (for-each (^l (write l p) (newline p)) (car x))) (cdr e))))
      (define (out e) (for-each proc e))
      (for-each out input))))
|#

(define input ((compose phase4 phase3 phase2 phase1 phase0 html->shtml) src))

;(emit-inputdef)

(when (file-exists? "out.scm")
  (delete-file "out.scm"))

(call-with-output-file
  "out.scm"
  (^p (for-each (^e (pp e p)(newline p)) input)))
